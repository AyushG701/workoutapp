{"ast":null,"code":"var _jsxFileName = \"D:\\\\mern projects\\\\workoutapp\\\\workoutapp\\\\frontend\\\\src\\\\context\\\\AuthContext.js\";\nimport { createContext, userReducer } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const AuthContext = /*#__PURE__*/createContext();\nexport const authReducer = (state, action) => {\n  switch (action.type) {\n    case \"LOGIN\":\n      return {\n        user: action.payload\n      };\n    case \"LOGOUT\":\n      return {\n        user: null\n      };\n    default:\n      return state;\n  }\n};\nexport const AuthContextProvider = ({\n  children\n}) => {\n  const [state, dispatch] = userReducer(authReducer, {\n    user: null\n  });\n  console.log(\"AuthContext state\", state);\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: {\n      ...state,\n      dispatch\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 23,\n    columnNumber: 5\n  }, this);\n};\n// With this setup, you can use the AuthContext and its associated dispatch function in your components to handle user authentication and manage the user state. For example, you can dispatch the \"LOGIN\" action to set the user object when a user successfully logs in and dispatch the \"LOGOUT\" action to clear the user object when they log out.\n_c = AuthContextProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthContextProvider\");","map":{"version":3,"names":["createContext","userReducer","jsxDEV","_jsxDEV","AuthContext","authReducer","state","action","type","user","payload","AuthContextProvider","children","dispatch","console","log","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/mern projects/workoutapp/workoutapp/frontend/src/context/AuthContext.js"],"sourcesContent":["import { createContext, userReducer } from \"react\";\r\n\r\nexport const AuthContext = createContext();\r\n\r\nexport const authReducer = (state, action) => {\r\n  switch (action.type) {\r\n    case \"LOGIN\":\r\n      return { user: action.payload };\r\n    case \"LOGOUT\":\r\n      return { user: null };\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n\r\nexport const AuthContextProvider = ({ children }) => {\r\n  const [state, dispatch] = userReducer(authReducer, {\r\n    user: null,\r\n  });\r\n  console.log(\"AuthContext state\", state);\r\n  return (\r\n    <AuthContext.Provider value={{ ...state, dispatch }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n// With this setup, you can use the AuthContext and its associated dispatch function in your components to handle user authentication and manage the user state. For example, you can dispatch the \"LOGIN\" action to set the user object when a user successfully logs in and dispatch the \"LOGOUT\" action to clear the user object when they log out.\r\n"],"mappings":";AAAA,SAASA,aAAa,EAAEC,WAAW,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEnD,OAAO,MAAMC,WAAW,gBAAGJ,aAAa,CAAC,CAAC;AAE1C,OAAO,MAAMK,WAAW,GAAGA,CAACC,KAAK,EAAEC,MAAM,KAAK;EAC5C,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAK,OAAO;MACV,OAAO;QAAEC,IAAI,EAAEF,MAAM,CAACG;MAAQ,CAAC;IACjC,KAAK,QAAQ;MACX,OAAO;QAAED,IAAI,EAAE;MAAK,CAAC;IAEvB;MACE,OAAOH,KAAK;EAChB;AACF,CAAC;AAED,OAAO,MAAMK,mBAAmB,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EACnD,MAAM,CAACN,KAAK,EAAEO,QAAQ,CAAC,GAAGZ,WAAW,CAACI,WAAW,EAAE;IACjDI,IAAI,EAAE;EACR,CAAC,CAAC;EACFK,OAAO,CAACC,GAAG,CAAC,mBAAmB,EAAET,KAAK,CAAC;EACvC,oBACEH,OAAA,CAACC,WAAW,CAACY,QAAQ;IAACC,KAAK,EAAE;MAAE,GAAGX,KAAK;MAAEO;IAAS,CAAE;IAAAD,QAAA,EACjDA;EAAQ;IAAAM,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACW,CAAC;AAE3B,CAAC;AACD;AAAAC,EAAA,GAXaX,mBAAmB;AAAA,IAAAW,EAAA;AAAAC,YAAA,CAAAD,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}